<!-- .github/copilot-instructions.md - guidance for AI code agents working on this repo -->
# Quick orientation

This is a Flutter mobile app (Android/iOS) that uses Firebase (Auth, Firestore) as the backend. Key entry points and files to read first:

- `lib/main.dart` — app entry; calls `Firebase.initializeApp(...)` with `lib/firebase_options.dart`.
- `lib/firebase_options.dart` — generated by FlutterFire CLI; currently configured for Android only.
- `lib/screens/auth_gate.dart` — central routing based on Firebase auth + `users` Firestore document `role` field (routes to `ManagerScreen` or `PlayerTabsScreen`).
- `lib/screens/*` — feature screens (booking, venues, events, manager dashboard).
- `lib/models/*` — simple data DTOs (see `event_model.dart`, `venue_model.dart`).

## Big picture

- Frontend: Flutter UI (Material3, custom fonts). App state is mostly ephemeral and driven by Firebase streams/queries.
- Backend: Firestore collections drive most features. The app expects collections like `users`, `bookings`, `venues`, and `events` and uses fields such as `role` (on user docs), `bookingDate` (Firestore Timestamp), and `bookingStatus` (`confirmed` / `completed`).
- Auth & routing: `AuthGate` listens to `FirebaseAuth.instance.authStateChanges()` and then fetches the user's Firestore doc to decide role-based navigation.

## Project-specific conventions & patterns

- UI: Prefer `StreamBuilder` for auth and live data; `FutureBuilder` for one-off reads (see `auth_gate.dart`, `dashboard_screen.dart`).
- State safety: Components check `mounted` before calling `setState` after async work — follow this pattern.
- Error reporting: Surface errors via `SnackBar` and simple scaffold-level messages. If a user document is missing or an error occurs, the app shows a sign-out button (see `auth_gate.dart`).
- Time data: Booking and event dates are stored as Firestore `Timestamp` objects; components cast to `Timestamp` then `.toDate()` before formatting (see `_BookingCard` in `dashboard_screen.dart`).
- Venue model: `venue_model.dart` includes `openingTime`, `closingTime`, and `slotDuration` — time-slot generation logic is implemented in screens rather than the model.

## Data flows & likely Firestore structure (discoverable patterns)

- users (docId = uid) { role: 'player' | 'manager', ... }
- bookings { userId, bookingDate: Timestamp, bookingStatus: 'confirmed'|'completed', venueName, timeSlot, ... }
- venues { name, location, sportType, pricePerHour, openingTime, closingTime, slotDuration }
- events { eventDate: Timestamp, venueName, entryFee, ... }

Note: queries that filter by multiple fields and order by a field (e.g., bookings where userId + bookingDate + bookingStatus and orderBy bookingDate) may require a composite Firestore index — add indexes via Firebase console when running into exceptions.

## Build / run / debug (developer workflow)

- Install deps: `flutter pub get`.
- Run on Android device/emulator: `flutter run -d <device-id>` (Android is the supported platform in `firebase_options.dart`).
- Build release APK: `flutter build apk` (ensure `android/app/google-services.json` is present — this repo includes one).
- Re-configure Firebase options for other platforms: run the FlutterFire CLI (`flutterfire configure`) and regenerate `lib/firebase_options.dart` if you add web/iOS/macos/windows support. If `DefaultFirebaseOptions` throws UnsupportedError for a platform, it means that platform isn't configured yet.

## Integration points & external dependencies

- Firebase: Auth + Firestore are used throughout. Some features described in `README.md` (eSewa payments, Cloud Functions for notifications) are not present in the Flutter client; look for additional server-side code (Cloud Functions) in the repository root or ask the maintainers.
- Android config: `android/app/google-services.json` is present — the project expects Android Firebase setup out-of-the-box.

## Common fixes & guidance for edits

- Always ensure `WidgetsFlutterBinding.ensureInitialized()` and `await Firebase.initializeApp(...)` run before `runApp()` (see `main.dart`).
- When adding Firestore queries that use `where` + `orderBy`, run the app and follow the index error link to create the required composite index.
- Follow UI patterns in `lib/screens/` — use `SnackBar` for user-visible errors and `CircularProgressIndicator` while awaiting async results.
- Keep field names consistent with existing code: `bookingDate` (Timestamp), `bookingStatus`, `userId`, `role`.

## Where to change things

- Add new screens under `lib/screens/` and wire role-based access through `auth_gate.dart`.
- Add data helpers or services (thin wrappers around Firestore) in a new `lib/services/` folder for larger changes.

If anything above is unclear or you'd like me to include example code snippets (e.g., recommended Firestore helper functions or a sample composite index JSON), tell me which section to expand and I will iterate.
